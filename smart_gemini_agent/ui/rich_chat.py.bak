"""
Rich —Ç–µ—Ä–º–∏–Ω–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è Smart Gemini Agent
"""

import asyncio
import time
from datetime import datetime
from typing import Dict, Any, Optional

from rich.console import Console
from rich.prompt import Prompt
from rich.table import Table
from rich import box

from .display_utils import DisplayUtils


class RichInteractiveChat:
    """–ë–æ–≥–∞—Ç—ã–π —Ç–µ—Ä–º–∏–Ω–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è AI-–∞–≥–µ–Ω—Ç–∞"""

    def __init__(self, agent):
        self.console = Console()
        self.agent = agent
        self.history = []
        self.current_thread = "main"
        self.show_timestamps = True
        self.theme = "dark"
        self._last_dir_files = []
        self._last_dir_dirs = []

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —É—Ç–∏–ª–∏—Ç—ã –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
        self.display = DisplayUtils(self.console)

        # –ü–æ–¥–∫–ª—é—á–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –¥–ª—è —Å–∏—Å—Ç–µ–º—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏, –µ—Å–ª–∏ –æ–Ω–∞ –¥–æ—Å—Ç—É–ø–Ω–∞
        if getattr(self.agent, "guardrails", None) is not None:
            try:
                self.agent.guardrails.confirmation_handler = self._confirm_risky_action
            except Exception:
                pass

        # –°—Ç–∏–ª–∏
        self.styles = {
            "user": "bold blue",
            "agent": "green",
            "system": "yellow",
            "error": "bold red",
            "success": "bold green",
            "info": "cyan",
            "warning": "orange3",
            "path": "bold magenta",
            "command": "bold white on blue",
        }

    def clear_screen(self):
        """–û—á–∏—Å—Ç–∫–∞ —ç–∫—Ä–∞–Ω–∞"""
        self.console.clear()

    def get_user_input(self) -> Optional[str]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤–≤–æ–¥–∞ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            user_input = Prompt.ask(
                "[bold blue]üí¨ You[/bold blue]", console=self.console
            ).strip()

            return user_input if user_input else None

        except (KeyboardInterrupt, EOFError):
            return None

    def add_to_history(self, content: str, entry_type: str):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –≤ –∏—Å—Ç–æ—Ä–∏—é"""
        timestamp = datetime.now().strftime("%H:%M:%S") if self.show_timestamps else ""

        self.history.append(
            {"timestamp": timestamp, "type": entry_type, "content": content}
        )

        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –∏—Å—Ç–æ—Ä–∏–∏
        if len(self.history) > 1000:
            self.history = self.history[-500:]

    async def process_system_command(self, command: str) -> bool:
        """
        –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏—Å—Ç–µ–º–Ω—ã—Ö –∫–æ–º–∞–Ω–¥

        Returns:
            True –µ—Å–ª–∏ –∫–æ–º–∞–Ω–¥–∞ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞, False –µ—Å–ª–∏ –Ω—É–∂–Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å
        """
        command = command.lower().strip()

        if command == "/quit" or command == "/exit":
            return False

        elif command == "/help":
            self.display.display_help()

        elif command == "/clear":
            self.clear_screen()
            self.display.print_header()
            self.display.print_status_bar(self.agent)

        elif command == "/status":
            if self.agent:
                status = self.agent.get_status()
                self.display.display_status_info(status)
            else:
                self.display.display_error("Agent not initialized")

        elif command.startswith("/history"):
            parts = command.split()
            limit = int(parts[1]) if len(parts) > 1 and parts[1].isdigit() else 10
            self.display.display_history(self.history, limit)

        elif command.startswith("/tree"):
            parts = command.split(maxsplit=1)
            path = parts[1] if len(parts) > 1 else "."
            try:
                self.display.display_file_tree(path)
            except Exception as e:
                self.display.display_error(f"Cannot display tree for '{path}': {e}")

        elif command == "/tools":
            self.display_tools_info()

        elif command == "/export":
            self.export_history()

        elif command == "/reload":
            if self.agent:
                try:
                    self.agent.reload_prompt()
                    self.display.display_success("Prompt reloaded successfully")
                except Exception as e:
                    self.display.display_error(f"Failed to reload prompt: {e}")
            else:
                self.display.display_error("Agent not initialized")

        elif command == "/memory":
            if self.agent:
                self.agent.clear_context_memory()
                self.display.display_success("Context memory cleared")
            else:
                self.display.display_error("Agent not initialized")

        elif command == "/insights":
            if self.agent:
                try:
                    insights = self.agent.get_context_insights()
                    self.display_context_insights(insights)
                except Exception as e:
                    self.display.display_error(f"Failed to get insights: {e}")
            else:
                self.display.display_error("Agent not initialized")

        elif command.startswith("/metrics"):
            if self.agent and hasattr(self.agent, "print_metrics"):
                try:
                    self.agent.print_metrics()
                except Exception as e:
                    self.display.display_error(f"Failed to print metrics: {e}")
            else:
                self.display.display_error("Metrics module not available")

        elif command.startswith("/traces"):
            if self.agent and hasattr(self.agent, "get_recent_traces"):
                try:
                    parts = command.split()
                    count = int(parts[1]) if len(parts) > 1 and parts[1].isdigit() else 5
                    traces = self.agent.get_recent_traces(count)
                    if not traces:
                        self.display.display_info("No traces available")
                    else:
                        table = Table(title="Recent Traces", box=box.SIMPLE)
                        table.add_column("#", style="cyan")
                        table.add_column("Trace ID", style="white")
                        table.add_column("Spans", style="white")
                        for i, tr in enumerate(traces, 1):
                            tid = getattr(tr, "trace_id", str(i))
                            spans = getattr(tr, "span_count", getattr(tr, "spans", []))
                            span_count = spans if isinstance(spans, int) else (len(spans) if spans else 0)
                            table.add_row(str(i), str(tid), str(span_count))
                        self.console.print(table)
                except Exception as e:
                    self.display.display_error(f"Failed to show traces: {e}")
            else:
                self.display.display_error("Tracing module not available")

        elif command == "/memory_stats":
            if self.agent and hasattr(self.agent, "get_memory_statistics"):
                try:
                    stats = self.agent.get_memory_statistics()
                    if not stats:
                        self.display.display_info("No long-term memory or stats unavailable")
                    else:
                        table = Table(title="Long-term Memory Stats", box=box.SIMPLE)
                        for k, v in stats.items():
                            table.add_row(str(k), str(v))
                        self.console.print(table)
                except Exception as e:
                    self.display.display_error(f"Failed to get memory stats: {e}")
            else:
                self.display.display_error("Long-term memory not available")

        elif command.startswith("/memory_search"):
            if self.agent and hasattr(self.agent, "search_memory"):
                parts = command.split(maxsplit=1)
                query = parts[1].strip() if len(parts) > 1 else ""
                if not query:
                    self.display.display_error("Usage: /memory_search <query>")
                else:
                    asyncio.create_task(self._handle_memory_search(query))
            else:
                self.display.display_error("Long-term memory not available")

        elif command == "/memory_clear":
            if self.agent and hasattr(self.agent, "clear_long_term_memory"):
                try:
                    self.agent.clear_long_term_memory()
                    self.display.display_success("Long-term memory cleared")
                except Exception as e:
                    self.display.display_error(f"Failed to clear memory: {e}")
            else:
                self.display.display_error("Long-term memory not available")

        elif command.startswith("/plan"):
            if self.agent and hasattr(self.agent, "create_task_plan"):
                parts = command.split(maxsplit=1)
                task = parts[1].strip() if len(parts) > 1 else ""
                if not task:
                    self.display.display_error("Usage: /plan <task description>")
                else:
                    await self._handle_create_plan(task)
            else:
                self.display.display_error("Planning module not available")

        elif command == "/security_stats":
            if self.agent and hasattr(self.agent, "get_security_statistics"):
                try:
                    stats = self.agent.get_security_statistics()
                    if not stats:
                        self.display.display_info("No security stats available")
                    else:
                        table = Table(title="Security Guardrails Stats", box=box.SIMPLE)
                        for k, v in stats.items():
                            table.add_row(str(k), str(v))
                        self.console.print(table)
                except Exception as e:
                    self.display.display_error(f"Failed to get security stats: {e}")
            else:
                self.display.display_error("Security module not available")

        elif command == "/run_plan":
            if self.agent and hasattr(self.agent, "execute_next_task"):
                try:
                    plan = self._get_active_plan()
                    if not plan:
                        self.display.display_error("No active plan. Use /plan <task> first.")
                        return True

                    # –Ø–≤–Ω–æ–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø–µ—Ä–µ–¥ –ø–æ–ª–Ω—ã–º –∑–∞–ø—É—Å–∫–æ–º –ø–ª–∞–Ω–∞
                    if not self._confirm_plan_execution(plan):
                        self.display.display_info("Plan execution cancelled by user")
                        return True

                    while True:
                        try:
                            next_task = plan.get_next_task()
                        except Exception:
                            next_task = None
                        if not next_task:
                            # –ï—Å–ª–∏ –≤–∫–ª—é—á—ë–Ω —Ä–µ–∂–∏–º –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –∑–∞—Ü–∏–∫–ª–∏–≤–∞–Ω–∏—è, –ø–æ–ø—Ä–æ–±—É–µ–º –ø–µ—Ä–µ–∏—Å–ø–æ–ª–Ω–∏—Ç—å –æ–¥–Ω—É –ø—Ä–æ–≤–∞–ª–µ–Ω–Ω—É—é –∑–∞–¥–∞—á—É
                            try:
                                from ..planning.task_planner import TaskStatus as PlanStatus
                            except Exception:
                                PlanStatus = None
                            if (
                                getattr(self.agent, "_allow_loop_continuation", False)
                                and PlanStatus is not None
                            ):
                                try:
                                    failed_task = next((t for t in plan.subtasks if t.status == PlanStatus.FAILED), None)
                                except Exception:
                                    failed_task = None
                                if failed_task is not None:
                                    try:
                                        failed_task.status = PlanStatus.PENDING
                                        self.display.display_info(f"–ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ –ø–æ–¥–∑–∞–¥–∞—á–∏ {getattr(failed_task,'id','?')}")
                                        continue
                                    except Exception:
                                        pass
                            break

                        desc = getattr(next_task, "description", "")
                        self.display.display_info(f"‚ñ∂ –í—ã–ø–æ–ª–Ω—è—é –ø–æ–¥–∑–∞–¥–∞—á—É {getattr(next_task,'id','?')}: {desc}")

                        res = await self.agent.execute_next_task()

                        if res.get("completed"):
                            self.display.display_success(f"‚úÖ –ü–æ–¥–∑–∞–¥–∞—á–∞ {res.get('task_id')} –∑–∞–≤–µ—Ä—à–µ–Ω–∞")
                        elif "error" in res:
                            self.display.display_error(f"‚ùå –ü–æ–¥–∑–∞–¥–∞—á–∞ {res.get('task_id')} –æ—à–∏–±–∫–∞: {res.get('error')}")
                        elif "message" in res:
                            self.display.display_info(res.get("message"))

                        self._print_task_result(next_task)
                        self._print_plan_progress(plan)

                    try:
                        prog = plan.get_progress()
                        self.display.display_success(
                            f"Plan finished: completed={prog.get('completed',0)}, failed={prog.get('failed',0)}"
                        )
                        try:
                            table = Table(title="Plan Progress", box=box.SIMPLE)
                            for k in ("total", "completed", "failed", "in_progress", "pending", "completion_rate"):
                                if k in prog:
                                    table.add_row(str(k), str(prog[k]))
                            self.console.print(table)
                        except Exception:
                            pass
                        
                        # –ü–æ–ø—Ä–æ–±—É–µ–º –ø–æ–∫–∞–∑–∞—Ç—å –∏—Ç–æ–≥–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø–ª–∞–Ω–∞
                        try:
                            try:
                                from ..planning.task_planner import TaskStatus as PlanStatus
                            except Exception:
                                PlanStatus = None

                            completed_tasks = []
                            for t in getattr(plan, 'subtasks', []):
                                try:
                                    if PlanStatus is not None:
                                        if t.status == PlanStatus.COMPLETED:
                                            completed_tasks.append(t)
                                    else:
                                        if str(getattr(t, 'status', '')).lower() in ("completed", "done"):
                                            completed_tasks.append(t)
                                except Exception:
                                    pass

                            final_task = None
                            keywords = ("–∏—Ç–æ–≥", "–¥–æ–∫—É–º–µ–Ω—Ç", "—Ñ–∏–Ω–∞–ª", "—Ä–µ–∑—É–ª—å—Ç", "summary")
                            for t in completed_tasks:
                                desc = str(getattr(t, 'description', '')).lower()
                                if any(k in desc for k in keywords):
                                    final_task = t
                            if not final_task and completed_tasks:
                                final_task = completed_tasks[-1]

                            final_text = None
                            if final_task is not None:
                                final_text = getattr(final_task, 'result', None)
                            if not final_text and completed_tasks:
                                # –æ–±–æ–±—â–∏–º –∫—Ä–∞—Ç–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
                                parts = []
                                for t in completed_tasks[-3:]:
                                    rt = getattr(t, 'result', None)
                                    if rt:
                                        parts.append(str(rt))
                                if parts:
                                    final_text = "\n\n".join(parts)

                            if final_text:
                                text = str(final_text)
                                if len(text) > 2000:
                                    text = text[:2000] + "..."
                                self.console.print()
                                self.display.display_success("–ò—Ç–æ–≥–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø–ª–∞–Ω–∞:")
                                if hasattr(self, 'display') and hasattr(self.display, 'display_agent_response'):
                                    try:
                                        self.display.display_agent_response(text)
                                    except Exception:
                                        self.console.print(text)
                                else:
                                    self.console.print(text)
                        except Exception:
                            pass
                    except Exception:
                        pass
                except Exception as e:
                    self.display.display_error(f"Failed to run plan: {e}")
            else:
                self.display.display_error("Planning module not available")

        elif command in ["/next", "/next_task"]:
            if self.agent and hasattr(self.agent, "execute_next_task"):
                try:
                    plan = self._get_active_plan()
                    if plan:
                        try:
                            peek = plan.get_next_task()
                        except Exception:
                            peek = None
                        if peek:
                            desc = getattr(peek, "description", "")
                            self.display.display_info(f"‚ñ∂ –í—ã–ø–æ–ª–Ω—è—é –ø–æ–¥–∑–∞–¥–∞—á—É {getattr(peek,'id','?')}: {desc}")

                    res = await self.agent.execute_next_task()

                    if "error" in res:
                        self.display.display_error(res["error"])
                    elif "message" in res:
                        self.display.display_info(res["message"]) 
                    else:
                        if res.get("completed"):
                            self.display.display_success(f"‚úÖ –ü–æ–¥–∑–∞–¥–∞—á–∞ {res.get('task_id')} –∑–∞–≤–µ—Ä—à–µ–Ω–∞")
                        else:
                            self.display.display_error(f"‚ùå –ü–æ–¥–∑–∞–¥–∞—á–∞ {res.get('task_id')} –æ—à–∏–±–∫–∞: {res.get('error')}")

                    if plan and peek:
                        self._print_task_result(peek)
                        self._print_plan_progress(plan)
                except Exception as e:
                    self.display.display_error(f"Failed to execute next task: {e}")
            else:
                self.display.display_error("Planning module not available")

        elif command.startswith("/export_context"):
            if self.agent:
                try:
                    parts = command.split()
                    format_type = parts[1] if len(parts) > 1 else "json"
                    context_data = self.agent.export_context(format_type)
                    filename = f"agent_context_{datetime.now().strftime('%Y%m%d_%H%M%S')}.{format_type}"

                    with open(filename, "w", encoding="utf-8") as f:
                        f.write(context_data)

                    self.display.display_success(f"Context exported to {filename}")
                except Exception as e:
                    self.display.display_error(f"Failed to export context: {e}")
            else:
                self.display.display_error("Agent not initialized")

        elif command in ["/–ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å", "/continue"]:
            if self.agent:
                message = self.agent.enable_loop_continuation()
                self.display.display_success(message)
            else:
                self.display.display_error("Agent not initialized")

        elif command in ["/–æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å", "/stop_loop"]:
            if self.agent:
                message = self.agent.disable_loop_continuation()
                self.display.display_success(message)
            else:
                self.display.display_error("Agent not initialized")

        elif command == "/loop_status":
            if self.agent:
                status = self.agent.get_loop_continuation_status()
                status_text = "–≤–∫–ª—é—á–µ–Ω" if status else "–≤—ã–∫–ª—é—á–µ–Ω"
                self.console.print(f"[cyan]–†–µ–∂–∏–º –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –∑–∞—Ü–∏–∫–ª–∏–≤–∞–Ω–∏—è: {status_text}[/cyan]")
            else:
                self.display.display_error("Agent not initialized")

        else:
            self.display.display_error(f"Unknown command: {command}")
            self.display.display_help()

        return True

    async def _handle_memory_search(self, query: str):
        try:
            results = await self.agent.search_memory(query, k=5)
            if not results:
                self.display.display_info("No similar memories found")
                return
            table = Table(title=f"Memory Search: {query}", box=box.SIMPLE)
            table.add_column("#", style="cyan")
            table.add_column("Title", style="white")
            table.add_column("Score", style="white")
            for i, r in enumerate(results, 1):
                title = getattr(r, "title", getattr(r, "user_input", "entry"))
                score = getattr(r, "score", getattr(r, "similarity", "-"))
                table.add_row(str(i), str(title), str(score))
            self.console.print(table)
        except Exception as e:
            self.display.display_error(f"Failed memory search: {e}")

    async def _handle_create_plan(self, task: str):
        try:
            plan = await self.agent.create_task_plan(task)
            if not plan:
                self.display.display_info("Plan was not created")
                return
            self.display.display_success("Execution plan created")
            if getattr(self.agent, "task_planner", None):
                try:
                    self.agent.task_planner.print_plan(plan)
                except Exception:
                    pass
        except Exception as e:
            self.display.display_error(f"Failed to create plan: {e}")

    def _get_active_plan(self):
        plan = None
        if self.agent and hasattr(self.agent, "get_current_plan"):
            try:
                plan = self.agent.get_current_plan()
            except Exception:
                plan = None
        if not plan and self.agent is not None:
            plan = getattr(self.agent, "current_plan", None)
        return plan

    def _confirm_plan_execution(self, plan) -> bool:
        try:
            main_goal = getattr(plan, "main_goal", "")
            subtasks = getattr(plan, "subtasks", []) or []
            total = len(subtasks)
            self.console.print()
            self.console.print("[bold cyan]Execution plan overview[/bold cyan]")
            if main_goal:
                self.console.print(f"[cyan]Goal:[/cyan] {main_goal}")
            if total:
                self.console.print(f"[cyan]Subtasks:[/cyan] {total}")
                for i, t in enumerate(subtasks[:5], 1):
                    desc = str(getattr(t, "description", ""))
                    self.console.print(f"  {i}. {desc}")
                if total > 5:
                    self.console.print(f"... and {total - 5} more")
        except Exception:
            pass
        try:
            answer = Prompt.ask(
                "[bold yellow]Run this plan to completion?[/bold yellow] (y/n)",
                console=self.console,
            )
        except (KeyboardInterrupt, EOFError):
            return False
        if not answer:
            return False
        ans = answer.strip().lower()
        return ans in ("y", "yes", "–¥", "–¥–∞")

    async def _confirm_risky_action(self, action_description: str, risk_level: str) -> bool:
        try:
            self.console.print()
            self.console.print(f"[bold yellow]Confirmation required:[/bold yellow] {action_description}")
            if risk_level:
                self.console.print(f"[cyan]Risk level:[/cyan] {risk_level}")
            answer = Prompt.ask(
                "[bold yellow]Continue?[/bold yellow] (y/n)",
                console=self.console,
            )
        except (KeyboardInterrupt, EOFError):
            return False
        if not answer:
            return False
        ans = answer.strip().lower()
        return ans in ("y", "yes", "–¥", "–¥–∞")

    def _print_task_result(self, task) -> None:
        try:
            result_text = getattr(task, "result", None)
            if not result_text:
                return
            text = str(result_text)
            if self.agent and hasattr(self.agent, "response_formatter"):
                try:
                    text = self.agent.response_formatter.improve_file_content_formatting(
                        text
                    )
                except Exception:
                    pass
            if len(text) > 600:
                text = text[:600] + "..."
            self.console.print(text)
        except Exception:
            pass

    def _print_plan_progress(self, plan) -> None:
        if not plan:
            return
        try:
            prog = plan.get_progress()
            self.display.display_info(
                f"–ü—Ä–æ–≥—Ä–µ—Å—Å: –≤—ã–ø–æ–ª–Ω–µ–Ω–æ {prog.get('completed',0)}/{prog.get('total',0)}, –ø—Ä–æ–≤–∞–ª–µ–Ω–æ {prog.get('failed',0)}"
            )
        except Exception:
            pass

    def display_tools_info(self):
        """–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ —Å –∫–∞—Ç–µ–≥–æ—Ä–∏–∑–∞—Ü–∏–µ–π"""
        if not self.agent or not hasattr(self.agent, "tools_map"):
            self.display.display_error("Agent not initialized or tools not loaded")
            return

        # –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—É –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º
        for category, tools in self.agent.tools_map.items():
            if not tools:
                continue

            table = Table(
                title=f"[bold]{category.replace('_', ' ').title()}[/bold]",
                box=box.ROUNDED,
            )
            table.add_column("Tool", style="cyan", no_wrap=True)
            table.add_column("Description", style="white")

            for tool in tools:
                description = getattr(tool, "description", "No description")
                if len(description) > 80:
                    description = description[:77] + "..."
                table.add_row(tool.name, description)

            self.console.print(table)
            self.console.print()

        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
        examples_table = Table(title="[bold]üí° Smart Examples[/bold]", box=box.SIMPLE)
        examples_table.add_column("Command", style="green")
        examples_table.add_column("Description", style="white")

        examples = [
            ("—Å–æ–∑–¥–∞–π —Ñ–∞–π–ª readme.md —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º –ø—Ä–æ–µ–∫—Ç–∞", "Create file with content"),
            ("–ø—Ä–æ—á–∏—Ç–∞–π config.json", "Read and format file content"),
            ("—É–¥–∞–ª–∏ —Å—Ç–∞—Ä—ã–π —Ñ–∞–π–ª backup.txt", "Safe file deletion"),
            ("–ø–æ–∫–∞–∂–∏ —Ñ–∞–π–ª—ã", "List directory contents"),
            ("–Ω–∞–π–¥–∏ —Ñ–∞–π–ª—ã *.py", "Search for Python files"),
            ("–Ω–∞–π–¥–∏ –≤ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ Python", "Web search"),
        ]

        for cmd, desc in examples:
            examples_table.add_row(cmd, desc)

        self.console.print(examples_table)

        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –Ω–æ–≤—ã–µ –∫–æ–º–∞–Ω–¥—ã
        new_commands_table = Table(title="[bold]üöÄ New Commands[/bold]", box=box.SIMPLE)
        new_commands_table.add_column("Command", style="cyan")
        new_commands_table.add_column("Description", style="white")

        new_commands = [
            ("/insights", "Show performance analytics and context insights"),
            ("/export_context [json|markdown]", "Export agent context and statistics"),
            ("/reload", "Reload system prompt from file"),
            ("/memory", "Clear agent context memory"),
            ("/–ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å or /continue", "Enable loop continuation mode (ignore loop warnings)"),
            ("/–æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å or /stop_loop", "Disable loop continuation mode"),
            ("/loop_status", "Check loop continuation mode status"),
            ("/run_plan", "Execute current plan to completion"),
            ("/next", "Execute next available subtask from the plan"),
        ]

        for cmd, desc in new_commands:
            new_commands_table.add_row(cmd, desc)

        self.console.print(new_commands_table)

    def display_context_insights(self, insights: Dict[str, Any]):
        """–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞"""
        self.display.display_context_insights(insights)

    def _normalize_content_for_export(self, content: str) -> str:
        """–ù–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç –∫–æ–Ω—Ç–µ–Ω—Ç –¥–ª—è Markdown-—ç–∫—Å–ø–æ—Ä—Ç–∞: –∏–∑–≤–ª–µ–∫–∞–µ—Ç —Ç–µ–∫—Å—Ç –∏–∑ dict-–æ—Ç–≤–µ—Ç–æ–≤, —É–ª—É—á—à–∞–µ—Ç —Ñ–æ—Ä–º–∞—Ç –∏ –∫–æ–¥-–±–ª–æ–∫–∏."""
        try:
            text = str(content)
            # –°–ª—É—á–∞–π: dict –≤–∏–¥–∞ {'type': 'text', 'text': '...'}
            if text.startswith("{") and "'text':" in text:
                import re

                m = re.search(r"'text':\s*'(.+)'\s*[,}]", text, re.DOTALL)
                if m:
                    extracted = m.group(1)
                    # –†–∞–∑—ç–∫—Ä–∞–Ω–∏—Ä—É–µ–º \n –∏ —É–¥–∞–ª–∏–º –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã –ø–µ—Ä–µ–Ω–æ—Å–∞ –ø–∞–Ω–µ–ª–µ–π
                    extracted = extracted.replace("\\n", "\n")
                    return extracted.strip()
            return text
        except Exception:
            return str(content)

    def export_history(self):
        """–≠–∫—Å–ø–æ—Ä—Ç –∏—Å—Ç–æ—Ä–∏–∏ –≤ —Ñ–∞–π–ª"""
        if not self.history:
            self.display.display_error("–ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞")
            return

        filename = f"chat_history_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"

        try:
            with open(filename, "w", encoding="utf-8") as f:
                f.write("# Gemini AI Agent Chat History\n\n")
                f.write(
                    f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
                )

                for entry in self.history:
                    timestamp = entry.get("timestamp", "")
                    entry_type = entry.get("type", "unknown")
                    raw_content = entry.get("content", "")

                    # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–Ω—Ç–µ–Ω—Ç–∞
                    content = self._normalize_content_for_export(raw_content)
                    if self.agent and hasattr(self.agent, "response_formatter"):
                        try:
                            content = self.agent.response_formatter.improve_file_content_formatting(
                                content
                            )
                        except Exception:
                            pass

                    f.write(f"## {entry_type.title()} [{timestamp}]\n\n")
                    f.write(f"{content}\n\n")
                    f.write("---\n\n")

            self.display.display_success(f"–ò—Å—Ç–æ—Ä–∏—è —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞ –≤ {filename}")

        except Exception as e:
            self.display.display_error(f"–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞: {e}")

    def _display_step(self, chunk: Dict):
        """–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –æ–¥–Ω–æ–≥–æ —à–∞–≥–∞ –∏–∑ –ø–æ—Ç–æ–∫–∞ LangGraph"""
        final_response = None
        if "agent" in chunk:
            agent_step = chunk["agent"]
            if isinstance(agent_step, dict) and agent_step.get("messages"):
                messages = agent_step["messages"]
                for msg in messages:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤—ã–∑–æ–≤–æ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
                    if msg.tool_calls:
                        for tool_call in msg.tool_calls:
                            self.display.display_tool_call(
                                tool_call["name"], tool_call["args"]
                            )
                    # –ï—Å–ª–∏ —ç—Ç–æ –Ω–µ –≤—ã–∑–æ–≤ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞, –∞ –µ—Å—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç, —ç—Ç–æ –º—ã—Å–ª—å –∏–ª–∏ —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç
                    elif msg.content:
                        # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —Ç–µ–∫—Å—Ç
                        if self.agent and hasattr(self.agent, "response_formatter"):
                            content_str = self.agent.response_formatter.normalize_text(
                                msg.content
                            )
                        else:
                            content_str = str(msg.content)

                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ –º—ã—Å–ª—å—é –∞–≥–µ–Ω—Ç–∞
                        if "Thought:" in content_str or "Plan:" in content_str:
                            self.display.display_agent_thought(content_str)
                        # –í –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ, —ç—Ç–æ —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç
                        else:
                            final_response = content_str

        # –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
        if "tools" in chunk:
            tool_steps = chunk["tools"]

            def _handle_tool_msg(msg):
                """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –±–µ–∑ –≤—ã–≤–æ–¥–∞ –ø–∞–Ω–µ–ª–µ–π.
                –î–ª—è list_directory —Å–æ–±–∏—Ä–∞–µ–º –∏–º–µ–Ω–∞ –¥–ª—è —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞, –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º."""
                try:
                    name = getattr(msg, "name", "tool")
                    content_obj = getattr(msg, "content", msg)
                    if str(name).lower() in ("list_directory", "ls", "dir"):
                        # –ü—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤/–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π
                        try:
                            norm = (
                                self.agent.response_formatter.normalize_text(content_obj)
                                if self.agent and hasattr(self.agent, "response_formatter")
                                else str(content_obj)
                            )
                            import json
                            data = json.loads(norm)
                            candidates = []
                            if isinstance(data, dict):
                                for key in ("entries", "items", "files", "list", "result", "data"):
                                    if key in data and isinstance(data[key], list):
                                        candidates = data[key]
                                        break
                            elif isinstance(data, list):
                                candidates = data
                            for it in candidates:
                                if isinstance(it, dict):
                                    name_v = it.get("name") or it.get("path") or it.get("file")
                                    is_dir = bool(it.get("is_dir") or it.get("directory") or it.get("isDirectory"))
                                    if name_v:
                                        (self._last_dir_dirs if is_dir else self._last_dir_files).append(str(name_v))
                                else:
                                    self._last_dir_files.append(str(it))
                        except Exception:
                            # –§–æ–ª–±–µ–∫: –ø–∞—Ä—Å–∏–Ω–≥ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –æ—Ç–≤–µ—Ç–∞
                            try:
                                import re
                                text = (
                                    self.agent.response_formatter.normalize_text(content_obj)
                                    if self.agent and hasattr(self.agent, "response_formatter")
                                    else str(content_obj)
                                )
                                for tag, name_v in re.findall(r"\[(FILE|DIR)\]\s*([^\s\[\]\r\n]+)", text):
                                    if name_v:
                                        (self._last_dir_dirs if tag == "DIR" else self._last_dir_files).append(name_v)
                                for emoji, name_v in re.findall(r"(üìÑ|üìÅ)\s+([^\r\n]+)", text):
                                    n = name_v.strip()
                                    if n:
                                        (self._last_dir_dirs if emoji == "üìÅ" else self._last_dir_files).append(n)
                            except Exception:
                                pass
                    # –ù–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –Ω–∏–∫–∞–∫–∏—Ö –ø–∞–Ω–µ–ª–µ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
                except Exception:
                    pass

            if isinstance(tool_steps, list):
                for tool_msg in tool_steps:
                    _handle_tool_msg(tool_msg)
            elif isinstance(tool_steps, dict):
                # –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ dict: –∑–Ω–∞—á–µ–Ω–∏—è –º–æ–≥—É—Ç –±—ã—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏ –∏–ª–∏ —Å–ø–∏—Å–∫–∞–º–∏
                for v in tool_steps.values():
                    if isinstance(v, list):
                        for msg in v:
                            _handle_tool_msg(msg)
                    else:
                        _handle_tool_msg(v)
            else:
                # –ù–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç ‚Äî –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –≤—ã–≤–æ–¥
                pass

        # –õ–æ–≥–∏–∫–∞ –¥–ª—è __end__ –æ—Å—Ç–∞–µ—Ç—Å—è –∫–∞–∫ –∑–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç
        if "__end__" in chunk:
            messages = chunk["__end__"].get("messages", [])
            if messages:
                last_message = messages[-1]
                if hasattr(last_message, "content") and last_message.content:
                    if isinstance(last_message.content, list):
                        final_response = "\n".join(map(str, last_message.content))
                    else:
                        final_response = str(last_message.content)

                # –§–∏–Ω–∞–ª—å–Ω–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –±—É–¥–µ—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–æ –Ω–∞ –∑–∞–≤–µ—Ä—à–∞—é—â–µ–º —ç—Ç–∞–ø–µ –ø–æ–∫–∞–∑–∞

        return final_response

    async def run(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª —á–∞—Ç–∞"""
        self.clear_screen()
        self.display.print_header()
        self.display.print_status_bar(self.agent)

        self.console.print(
            "[dim]Type /help for available commands, /quit to exit[/dim]"
        )
        self.display.print_rule()

        try:
            while True:
                user_input = self.get_user_input()

                if user_input is None:
                    break

                if not user_input:
                    continue

                self.add_to_history(user_input, "user")

                if user_input.startswith("/"):
                    handled = await self.process_system_command(user_input)
                    if handled:
                        continue
                    else:
                        break

                if self.agent:
                    try:
                        start_time = time.time()
                        final_response = None
                        has_called_tool_in_this_turn = False
                        had_error_in_this_turn = False
                        # –ö—ç—à –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ª–∏—Å—Ç–∏–Ω–≥–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π (–¥–ª—è –∑–∞–º–µ–Ω—ã –º–∞—Å–æ–∫ –≤ —Ñ–∏–Ω–∞–ª—å–Ω–æ–º –æ—Ç–≤–µ—Ç–µ)
                        self._last_dir_files = []
                        self._last_dir_dirs = []

                        self.console.print()  # –ü—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º
                        self.display.print_rule(
                            title="[bold yellow]Agent Activity[/bold yellow]"
                        )

                        try:
                            async for chunk in self.agent.process_message(
                                user_input, self.current_thread
                            ):
                                # –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –æ –∑–∞—Ü–∏–∫–ª–∏–≤–∞–Ω–∏–∏
                                if "loop_warning" in chunk:
                                    warning_info = chunk["loop_warning"]
                                    self.console.print()
                                    self.console.print("[bold red]‚ö†Ô∏è –ü–†–ï–î–£–ü–†–ï–ñ–î–ï–ù–ò–ï –û –ó–ê–¶–ò–ö–õ–ò–í–ê–ù–ò–ò[/bold red]")
                                    self.console.print()
                                    self.console.print(warning_info["message"])
                                    self.console.print()
                                    # –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –æ–∂–∏–¥–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–π chunk (–º–æ–∂–µ—Ç –±—ã—Ç—å error –∏–ª–∏ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)
                                    continue

                                if "error" in chunk:
                                    self.display.display_error(chunk["error"])
                                    had_error_in_this_turn = True
                                    final_response = None
                                    break

                                # –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º, –±—ã–ª –ª–∏ –≤—ã–∑–≤–∞–Ω –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –≤ —ç—Ç–æ–º —Ö–æ–¥—É
                                if "tools" in chunk and chunk["tools"]:
                                    has_called_tool_in_this_turn = True

                                response_part = self._display_step(chunk)
                                if response_part:
                                    final_response = response_part
                        except KeyboardInterrupt:
                            self.console.print("\n‚ö†Ô∏è [yellow]–û–ø–µ—Ä–∞—Ü–∏—è –ø—Ä–µ—Ä–≤–∞–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º (Ctrl+C)[/yellow]")
                            raise
                        except asyncio.CancelledError:
                            self.console.print("\n‚ö†Ô∏è [yellow]–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞[/yellow]")
                            raise

                        self.display.print_rule()
                        self.console.print()  # –ü—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ –ø–æ—Å–ª–µ

                        if final_response:
                            # –ï—Å–ª–∏ –º–æ–¥–µ–ª—å –≤–µ—Ä–Ω—É–ª–∞ –º–∞—Å–∫–∏ –≤–º–µ—Å—Ç–æ –∏–º—ë–Ω, –∑–∞–º–µ–Ω–∏–º –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–µ –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
                            try:
                                if ("–°–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ç–µ–∫—É—â–µ–π —Ä–∞–±–æ—á–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏" in final_response or "–í–æ—Ç —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤" in final_response) and (self._last_dir_files or self._last_dir_dirs):
                                    lines = []
                                    wd = getattr(getattr(self.agent, "config", None), "filesystem_path", "").strip()
                                    header = (
                                        f"–í–æ—Ç —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ –∏ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π –≤ —Ç–µ–∫—É—â–µ–π —Ä–∞–±–æ—á–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ {wd}:"
                                        if "–í–æ—Ç —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤" in final_response
                                        else "–°–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ç–µ–∫—É—â–µ–π —Ä–∞–±–æ—á–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏:"
                                    )
                                    lines.append(header)
                                    if self._last_dir_files:
                                        lines.append("")
                                        lines.append("  ‚Ä¢ –§–∞–π–ª—ã:")
                                        for n in self._last_dir_files:
                                            lines.append(f"     ‚Ä¢ {n}")
                                    if self._last_dir_dirs:
                                        lines.append("  ‚Ä¢ –î–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏:")
                                        for n in self._last_dir_dirs:
                                            lines.append(f"     ‚Ä¢ {n}")
                                    final_response = "\n".join(lines)
                            except Exception:
                                pass

                            # –ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ —É–ª—É—á—à–∞–µ–º —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞
                            if self.agent and hasattr(self.agent, "response_formatter"):
                                try:
                                    final_response = self.agent.response_formatter.improve_file_content_formatting(
                                        final_response
                                    )
                                except Exception:
                                    pass
                            response_time = time.time() - start_time
                            self.add_to_history(final_response, "agent")
                            self.display.display_agent_response(
                                final_response, response_time
                            )
                        elif has_called_tool_in_this_turn and not had_error_in_this_turn:
                            final_response = "‚úÖ –ó–∞–¥–∞—á–∞ —É—Å–ø–µ—à–Ω–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞."
                            response_time = time.time() - start_time
                            self.add_to_history(final_response, "agent")
                            self.display.display_agent_response(
                                final_response, response_time
                            )
                        elif not had_error_in_this_turn:
                            self.console.print(
                                "‚ö†Ô∏è [yellow]Agent finished without a final response.[/yellow]"
                            )

                    except Exception as e:
                        error_msg = f"Error processing message: {str(e)}"
                        self.add_to_history(error_msg, "error")
                        self.display.display_error(error_msg)
                else:
                    self.display.display_error("Agent not initialized")

                self.console.print()
        
        except KeyboardInterrupt:
            self.console.print("\n‚ö†Ô∏è [yellow]–ü—Ä–µ—Ä–≤–∞–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º (Ctrl+C)[/yellow]")
        except Exception as e:
            error_msg = f"Critical error in chat loop: {str(e)}"
            self.add_to_history(error_msg, "error")
            self.display.display_error(error_msg)
        finally:
            self.console.print("[dim]Goodbye! üëã[/dim]")
